Index: plplot-5.9.7/drivers/linuxvga.c
===================================================================
--- plplot-5.9.7.orig/drivers/linuxvga.c	2011-01-08 12:20:09.000000000 +0100
+++ plplot-5.9.7/drivers/linuxvga.c	2011-01-08 15:37:11.000000000 +0100
@@ -39,8 +39,8 @@
 
 /* INDENT ON */
 
-static PLINT vgax = 639;
-static PLINT vgay = 479;
+static PLINT vgax = 319;
+static PLINT vgay = 239;
 
 /* A flag to tell us whether we are in text or graphics mode */
 
@@ -95,7 +95,7 @@
 /* What kind of VGA mode one wants is set up here.
  * It can be easyly made interactive! */
 
-    mode = G640x480x16;         /* See <vga.h> for a list */
+    mode = G320x240x16M32;         /* See <vga.h> for a list */
     if ( vga_hasmode( mode ) )
         vga_setmode( mode );
     else
@@ -202,24 +202,40 @@
 void
 plD_state_vga( PLStream *pls, PLINT op )
 {
+   static const int vga_palette[16] = {
+      0x000000, 0x000080, 0x008000, 0x008080, 
+      0x800000, 0x800080, 0x808000, 0xc0c0c0,
+      0x808080, 0x0000ff, 0x00ff00, 0x00ffff,
+      0xff0000, 0xff00ff, 0xffff00, 0xffffff
+   };
+   int r, g, b;
+
     switch ( op )
     {
     case PLSTATE_WIDTH:
         break;
 
     case PLSTATE_COLOR0:
-        if ( pls->color )
+        if ( !pls->color )
         {
-            /* Maybe it would be wiser to use a set of 16 relevant colors only
-             * and just fix it to black if col is exceeded 16.        */
-
-            col = ( pls->icol0 ) % totcol;        /* Color modulo # of colors
-                                                   * avail */
-            vga_setcolor( col );
+	   r = g = b = pls->icol0 ? 0xff : 0;
         }
-        break;
-
+	else
+	{
+	   r = pls->curcolor.r, g = pls->curcolor.g, b = pls->curcolor.b;
+	}
+	vga_setrgbcolor (r, g, b);
+	break;
     case PLSTATE_COLOR1:
+        if ( !pls->color )
+        {
+	   r = g = b = pls->curcolor.r;
+        }
+	else
+	{
+	   r = pls->curcolor.r, g = pls->curcolor.g, b = pls->curcolor.b;
+	}
+	vga_setrgbcolor( r, g, b );
         break;
     }
 }
