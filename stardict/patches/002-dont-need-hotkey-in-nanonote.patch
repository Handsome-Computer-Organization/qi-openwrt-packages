don't need hotkey in nanonote

From: Xiangfu Liu <xiangfu@sharism.cc>


---

 configure.in              |   26 ++-
 m4/nls.m4                 |   31 ++++
 src/class_factory.cpp     |    2 
 src/conf.cpp              |    6 -
 src/mainwin.cpp           |    9 +
 src/stardict.cpp          |   35 +++-
 src/x11_iskeyspressed.cpp |  351 ---------------------------------------------
 src/x11_iskeyspressed.hpp |   65 --------
 8 files changed, 75 insertions(+), 450 deletions(-)
 create mode 100644 m4/nls.m4


diff --git a/configure.in b/configure.in
index 83d3d95..6be40db 100644
--- a/configure.in
+++ b/configure.in
@@ -414,21 +414,21 @@ dnl ==========================================================================
 
 # Checks for header files. need by Solaris.
 AC_PATH_XTRA
-if test -n "$X_CFLAGS"; then
-CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-fi
-if test -n "$X_LIBS"; then
-LDFLAGS="$LDFLAGS $X_LIBS"
-fi
-if test -n "$X_PRE_LIBS"; then
-LDFLAGS="$LDFLAGS $X_PRE_LIBS"
-fi
-if test -n "$X_EXTRA_LIBS"; then
-LDFLAGS="$LDFLAGS $X_EXTRA_LIBS"
-fi
+#if test -n "$X_CFLAGS"; then
+#CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+#fi
+#if test -n "$X_LIBS"; then
+#LDFLAGS="$LDFLAGS $X_LIBS"
+#fi
+#if test -n "$X_PRE_LIBS"; then
+#LDFLAGS="$LDFLAGS $X_PRE_LIBS"
+#fi
+#if test -n "$X_EXTRA_LIBS"; then
+#LDFLAGS="$LDFLAGS $X_EXTRA_LIBS"
+#fi
 
 # Checks for libraries.
-AC_CHECK_LIB([X11], [main], , [AC_MSG_ERROR([X11 lib not found])])
+#AC_CHECK_LIB([X11], [main], , [AC_MSG_ERROR([X11 lib not found])])
 
 AC_SUBST(STARDICT_LIBS)
 AC_SUBST(STARDICT_CFLAGS)
diff --git a/m4/nls.m4 b/m4/nls.m4
new file mode 100644
index 0000000..7967cc2
--- /dev/null
+++ b/m4/nls.m4
@@ -0,0 +1,31 @@
+# nls.m4 serial 3 (gettext-0.15)
+dnl Copyright (C) 1995-2003, 2005-2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2003.
+
+AC_PREREQ(2.50)
+
+AC_DEFUN([AM_NLS],
+[
+  AC_MSG_CHECKING([whether NLS is requested])
+  dnl Default is enabled NLS
+  AC_ARG_ENABLE(nls,
+    [  --disable-nls           do not use Native Language Support],
+    USE_NLS=$enableval, USE_NLS=yes)
+  AC_MSG_RESULT($USE_NLS)
+  AC_SUBST(USE_NLS)
+])
diff --git a/src/class_factory.cpp b/src/class_factory.cpp
index 8bff538..d1dddc2 100644
--- a/src/class_factory.cpp
+++ b/src/class_factory.cpp
@@ -54,7 +54,7 @@ void *PlatformFactory::create_class_by_name(const std::string& name, void *param
 #ifdef _WIN32
 		return new win32_hotkeys();
 #else
-		return new x11_hotkeys(GTK_WINDOW(param));
+		return NULL; //new x11_hotkeys(GTK_WINDOW(param));
 #endif
 	}
 	return NULL;
diff --git a/src/conf.cpp b/src/conf.cpp
index 2d0f89d..a35bc5c 100644
--- a/src/conf.cpp
+++ b/src/conf.cpp
@@ -34,9 +34,9 @@ const int DEFAULT_WINDOW_WIDTH=238;
 const int DEFAULT_WINDOW_HEIGHT=279;
 const int DEFAULT_HPANED_POS=79;
 #else
-const int DEFAULT_WINDOW_WIDTH=463;
-const int DEFAULT_WINDOW_HEIGHT=321;
-const int DEFAULT_HPANED_POS=127;
+const int DEFAULT_WINDOW_WIDTH=320;
+const int DEFAULT_WINDOW_HEIGHT=240;
+const int DEFAULT_HPANED_POS=79;
 #endif
 
 std::auto_ptr<AppConf> conf;
diff --git a/src/mainwin.cpp b/src/mainwin.cpp
index 7005f7b..5bda8be 100644
--- a/src/mainwin.cpp
+++ b/src/mainwin.cpp
@@ -129,10 +129,10 @@ void TopWin::Create(GtkWidget *vbox)
 	gtk_box_pack_start(GTK_BOX(hbox),button,false,false,0);
 	gtk_widget_set_tooltip_text(button,_("Go Back - Right button: history (Alt+Left)"));
 
-	GtkWidget *label;
-	label = gtk_label_new("\t");
-	gtk_widget_show(label);
-	gtk_box_pack_start(GTK_BOX(hbox),label,false,false,0);
+	// GtkWidget *label;
+	// label = gtk_label_new("\t");
+	// gtk_widget_show(label);
+	// gtk_box_pack_start(GTK_BOX(hbox),label,false,false,0);
 
 	button=gtk_button_new();
 	gtk_container_add(GTK_CONTAINER(button),gtk_image_new_from_stock(GTK_STOCK_HOME,GTK_ICON_SIZE_BUTTON));
@@ -2665,6 +2665,7 @@ void MidWin::Create(GtkWidget *vbox)
 
 	notebook = gtk_notebook_new();
 	gtk_widget_show(notebook);
+	gtk_widget_set_size_request(GTK_WIDGET(notebook), 50, 20);
 	gtk_notebook_set_show_tabs(GTK_NOTEBOOK(notebook), false);
 	gtk_notebook_set_show_border(GTK_NOTEBOOK(notebook),false);
 
diff --git a/src/stardict.cpp b/src/stardict.cpp
index 326ca4a..0e820ed 100644
--- a/src/stardict.cpp
+++ b/src/stardict.cpp
@@ -351,9 +351,9 @@ void AppCore::Create(gchar *queryword)
 	oTopWin.Create(vbox);
 	oMidWin.Create(vbox);
 	oBottomWin.Create(vbox);
-	unlock_keys.reset(static_cast<hotkeys *>(PlatformFactory::create_class_by_name("hotkeys",
-										       GTK_WINDOW(window))));
-	unlock_keys->set_comb(combnum2str(conf->get_int_at("dictionary/scan_modifier_key")));
+	//unlock_keys.reset(static_cast<hotkeys *>(PlatformFactory::create_class_by_name("hotkeys",
+	//									       GTK_WINDOW(window))));
+	//unlock_keys->set_comb(combnum2str(conf->get_int_at("dictionary/scan_modifier_key")));
 	oFloatWin.Create();
 	bool scan=conf->get_bool_at("dictionary/scan_selection");
 	oDockLet.reset(PlatformFactory::create_tray_icon(window, scan,
@@ -2005,10 +2005,19 @@ private:
 
 void AppCore::PopupPrefsDlg()
 {
+    static std::list<std::string> posb_combs;
+    if (posb_combs.empty()) {
+        posb_combs.push_back("Win");
+        posb_combs.push_back("Shift");
+        posb_combs.push_back("Alt");
+        posb_combs.push_back("Ctrl");
+        posb_combs.push_back("Ctrl+Alt");
+    }
+
 	if (!prefs_dlg) {
 		prefs_dlg = new PrefsDlg(GTK_WINDOW(window),
-					 get_impl(oAppSkin.icon),
-					 unlock_keys->possible_combs());
+                                 get_impl(oAppSkin.icon),
+                                 posb_combs);
 		bool enbcol =
 			conf->get_bool_at("dictionary/enable_collation");
 		int colf =
@@ -2153,17 +2162,17 @@ void AppCore::Quit()
 	if (!conf->get_bool_at("main_window/maximized")) {
 		gint width, height;
 		gtk_window_get_size(GTK_WINDOW(window), &width, &height);
-    conf->set_int_at("main_window/window_width", width);
-    conf->set_int_at("main_window/window_height", height);
+		conf->set_int_at("main_window/window_width", width);
+		conf->set_int_at("main_window/window_height", height);
 	}
 	gint pos = gtk_paned_get_position(GTK_PANED(oMidWin.hpaned));
-  conf->set_int_at("main_window/hpaned_pos", pos);
+	conf->set_int_at("main_window/hpaned_pos", pos);
 
 	if (conf->get_bool_at("floating_window/lock")) {
 		gint x, y;
 		gtk_window_get_position(GTK_WINDOW(oFloatWin.FloatWindow), &x, &y);
-    conf->set_int_at("floating_window/lock_x", x);
-    conf->set_int_at("floating_window/lock_y", y);
+		conf->set_int_at("floating_window/lock_x", x);
+		conf->set_int_at("floating_window/lock_y", y);
 	}
 
 	End();
@@ -2171,9 +2180,9 @@ void AppCore::Quit()
 #ifdef CONFIG_GNOME
 	bonobo_object_unref (stardict_app_server);
 #endif
-   unlock_keys.reset(0);
-	 conf.reset(0);
-	 gtk_main_quit();
+	unlock_keys.reset(0);
+	conf.reset(0);
+	gtk_main_quit();
 }
 
 void AppCore::on_main_win_hide_list_changed(const baseconfval* hideval)
diff --git a/src/x11_iskeyspressed.cpp b/src/x11_iskeyspressed.cpp
index 15e8fb0..8b13789 100644
--- a/src/x11_iskeyspressed.cpp
+++ b/src/x11_iskeyspressed.cpp
@@ -1,352 +1 @@
-/* 
- * This file part of StarDict - A international dictionary for GNOME.
- * http://stardict.sourceforge.net
- *
- * Copyright (C) 2005 Evgeniy <dushistov@mail.ru>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Library General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
 
-/*
- * goal: react on key press even if there are window 
- * have no focus in XWindows. This code based on xbindkeys.
- */
-
-#ifdef HAVE_CONFIG_H
-#  include "config.h"
-#endif
-
-#include "gtk_iskeyspressed.hpp"
-
-#include "x11_iskeyspressed.hpp"
-
-
-
-unsigned int x11_hotkeys::numlock_mask, x11_hotkeys::scrolllock_mask, 
-  x11_hotkeys::capslock_mask;
-
-void x11_hotkeys::get_offending_modifiers(Display * dpy)
-{
-  int i;
-  XModifierKeymap *modmap;
-  KeyCode nlock, slock;
-  static int mask_table[8] = {
-    ShiftMask, LockMask, ControlMask, Mod1Mask,
-    Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask
-  };
-
-  nlock = XKeysymToKeycode (dpy, XK_Num_Lock);
-  slock = XKeysymToKeycode (dpy, XK_Scroll_Lock);
-
-  /*
-   * Find out the masks for the NumLock and ScrollLock modifiers,
-   * so that we can bind the grabs for when they are enabled too.
-   */
-  modmap = XGetModifierMapping (dpy);
-
-  if (modmap != NULL && modmap->max_keypermod > 0) {
-    for (i = 0; i < 8 * modmap->max_keypermod; i++) {
-      if (modmap->modifiermap[i] == nlock && nlock != 0)
-				numlock_mask = mask_table[i / modmap->max_keypermod];
-      else if (modmap->modifiermap[i] == slock && slock != 0)
-				scrolllock_mask = mask_table[i / modmap->max_keypermod];
-    }
-  }
-
-  capslock_mask = LockMask;
-
-  if (modmap)
-    XFreeModifiermap (modmap);
-}
-
-void x11_hotkeys::my_grab_key(Display * dpy, KeyCode keycode, 
-			   unsigned int modifier, Window win)
-{
-  modifier &= ~(numlock_mask | capslock_mask | scrolllock_mask);
-
-
-  XGrabKey(dpy, keycode, modifier, (win ? win : DefaultRootWindow(dpy)),
-	   False, GrabModeAsync, GrabModeAsync);
-
-  if (modifier == AnyModifier)
-    return;
-
-  if (numlock_mask)
-    XGrabKey (dpy, keycode, modifier | numlock_mask,
-	      (win ? win : DefaultRootWindow (dpy)),
-	      False, GrabModeAsync, GrabModeAsync);
-
-  if (capslock_mask)
-    XGrabKey (dpy, keycode, modifier | capslock_mask,
-	      (win ? win : DefaultRootWindow (dpy)),
-	      False, GrabModeAsync, GrabModeAsync);
-
-  if (scrolllock_mask)
-    XGrabKey (dpy, keycode, modifier | scrolllock_mask,
-	      (win ? win : DefaultRootWindow (dpy)),
-	      False, GrabModeAsync, GrabModeAsync);
-
-  if (numlock_mask && capslock_mask)
-    XGrabKey (dpy, keycode, modifier | numlock_mask | capslock_mask,
-	      (win ? win : DefaultRootWindow (dpy)),
-	      False, GrabModeAsync, GrabModeAsync);
-
-  if (numlock_mask && scrolllock_mask)
-    XGrabKey (dpy, keycode, modifier | numlock_mask | scrolllock_mask,
-	      (win ? win : DefaultRootWindow (dpy)),
-	      False, GrabModeAsync, GrabModeAsync);
-
-  if (capslock_mask && scrolllock_mask)
-    XGrabKey (dpy, keycode, modifier | capslock_mask | scrolllock_mask,
-	      (win ? win : DefaultRootWindow (dpy)),
-	      False, GrabModeAsync, GrabModeAsync);
-
-  if (numlock_mask && capslock_mask && scrolllock_mask)
-    XGrabKey (dpy, keycode,
-	      modifier | numlock_mask | capslock_mask | scrolllock_mask,
-	      (win ? win : DefaultRootWindow (dpy)), False, GrabModeAsync,
-	      GrabModeAsync);
-
-}
-
-
-void x11_hotkeys::my_grab_button(Display * dpy, unsigned int button, 
-			      unsigned int modifier, Window win)
-{
-  modifier &= ~(numlock_mask | capslock_mask | scrolllock_mask);
-
-  XGrabButton (dpy, button, modifier, (win ? win : DefaultRootWindow (dpy)),
-	       False, ButtonPressMask | ButtonReleaseMask,
-	       GrabModeAsync, GrabModeAsync, None, None);
-
-  if (modifier == AnyModifier)
-    return;
-
-  if (numlock_mask)
-    XGrabButton (dpy, button, modifier | numlock_mask,
-		 (win ? win : DefaultRootWindow (dpy)),
-		 False, ButtonPressMask | ButtonReleaseMask,
-		 GrabModeAsync, GrabModeAsync, None, None);
-
-
-  if (capslock_mask)
-    XGrabButton (dpy, button, modifier | capslock_mask,
-		 (win ? win : DefaultRootWindow (dpy)),
-		 False, ButtonPressMask | ButtonReleaseMask,
-		 GrabModeAsync, GrabModeAsync, None, None);
-
-  if (scrolllock_mask)
-    XGrabButton (dpy, button, modifier | scrolllock_mask,
-		 (win ? win : DefaultRootWindow (dpy)),
-		 False, ButtonPressMask | ButtonReleaseMask,
-		 GrabModeAsync, GrabModeAsync, None, None);
-
-  if (numlock_mask && capslock_mask)
-    XGrabButton (dpy, button, modifier | numlock_mask | capslock_mask,
-		 (win ? win : DefaultRootWindow (dpy)),
-		 False, ButtonPressMask | ButtonReleaseMask,
-		 GrabModeAsync, GrabModeAsync, None, None);
-
-  if (numlock_mask && scrolllock_mask)
-    XGrabButton (dpy, button, modifier | numlock_mask | scrolllock_mask,
-		 (win ? win : DefaultRootWindow (dpy)),
-		 False, ButtonPressMask | ButtonReleaseMask,
-		 GrabModeAsync, GrabModeAsync, None, None);
-
-  if (capslock_mask && scrolllock_mask)
-    XGrabButton (dpy, button, modifier | capslock_mask | scrolllock_mask,
-		 (win ? win : DefaultRootWindow (dpy)),
-		 False, ButtonPressMask | ButtonReleaseMask,
-		 GrabModeAsync, GrabModeAsync, None, None);
-
-  if (numlock_mask && capslock_mask && scrolllock_mask)
-    XGrabButton (dpy, button,
-		 modifier | numlock_mask | capslock_mask | scrolllock_mask,
-		 (win ? win : DefaultRootWindow (dpy)), False,
-		 ButtonPressMask | ButtonReleaseMask, GrabModeAsync,
-		 GrabModeAsync, None, None);
-}
-
-bool x11_hotkeys::grab_keys(Display *dpy, Keys_t keys[], int nb_keys)
-{
-  int i;
-  int min, max;
-  int screen;
-  
-
-  XDisplayKeycodes(dpy, &min, &max);
-
-#ifdef DEBUG  
-  printf("\n");
-  printf("min_keycode=%d     max_keycode=%d (ie: know keycodes)\n", 
-	 min, max);
-#endif  
-
-
-  for (i = 0; i < nb_keys; i++) {
-#ifdef DEBUG
-    print_key(dpy, &keys[i]);
-#endif
-    if (keys[i].type == SYM) {
-      for (screen = 0; screen < ScreenCount (dpy); screen++) {
-				my_grab_key(dpy, XKeysymToKeycode(dpy, keys[i].key.sym),
-										keys[i].modifier, RootWindow(dpy, screen));
-      }
-    } else if (keys[i].type == BUTTON) {
-      for (screen = 0; screen < ScreenCount (dpy); screen++) {
-	my_grab_button(dpy, keys[i].key.button, keys[i].modifier,
-		       RootWindow (dpy, screen));
-      }
-    } else {
-      if (keys[i].key.code >= min && keys[i].key.code <= max) {
-	for (screen = 0; screen < ScreenCount (dpy); screen++) {
-	  my_grab_key (dpy, keys[i].key.code, keys[i].modifier,
-		       RootWindow (dpy, screen));
-	}
-      } else {
-#ifdef DEBUG	
-	print_key (dpy, &keys[i]);
-
-
-	fprintf (stderr,
-		 "  The keycode %d cannot be used, as it's not between the\n"
-		 "  min(%d) and max(%d) keycode of your keyboard.\n"
-		 "  Please increase the 'maximum' value in\n"
-		 "    /usr/X11R6/lib/X11/xkb/keycodes/xfree86,\n"
-		 "  then restart X.\n", keys[i].key.code, min, max);	
-#endif	
-	return false;
-      }
-    }
-  }
-
-  return true;
-}
-
-
-x11_hotkeys::x11_hotkeys(GtkWindow *win_) : 
-  win(win_),
-  pressed(false),
-  def_hot_keys(new gtk_hotkeys(win_))
-{
-  possb_combs=def_hot_keys->possible_combs();
-  possb_combs.push_back("Ctrl+e");
-  possb_combs.push_back("F1");
-  possb_combs.push_back("F2");
-  possb_combs.push_back("F3");
-  possb_combs.push_back("F4");
-  display=gdk_x11_display_get_xdisplay(gdk_screen_get_display(gtk_window_get_screen(win)));
-  get_offending_modifiers(display);
-  gdk_window_add_filter(NULL, GdkFilterFunc(key_filter), this);
-}
-
-x11_hotkeys::~x11_hotkeys()
-{
-  ungrabkeys();
-}
-
-const std::list<std::string>& x11_hotkeys::possible_combs()
-{
-  return possb_combs;
-}
-
-void x11_hotkeys::set_comb(const std::string& val)
-{
-  if (comb==val)
-    return;
-
-  unsigned int modifier=0;
-  KeySym key=0;
-  std::string::size_type pos=std::string::npos;
-
-  do {
-    std::string::size_type prev_pos=pos;
-    pos=val.find('+', pos+1);
-    std::string cur;
-    if (pos!=std::string::npos)
-      cur.assign(val, prev_pos+1, pos-prev_pos-1);
-    else
-      cur.assign(val, prev_pos+1, val.length()-prev_pos-1);
-    if (cur=="Ctrl") {
-      modifier|=ControlMask;
-    } else if (cur=="Alt") {
-      modifier|=Mod1Mask;
-    } else if (cur=="Shift") {
-      modifier|=ShiftMask;
-    } else if (cur=="Win") {
-      modifier|=Mod4Mask;
-    } else {
-      key=XStringToKeysym(cur.c_str());
-	}
-  } while (pos!=std::string::npos);
-
-  comb=val;
-  pressed=false;
-  grab_key.key.sym=0;
-  if (key!=0) {
-    ungrabkeys();
-    grab_key.type=SYM;
-    grab_key.event_type=PRESS;
-    grab_key.key.sym=key;
-    grab_key.modifier=modifier;
-    grab_keys(display, &grab_key, 1);
-  } else
-    def_hot_keys->set_comb(val);
-}
-
-bool x11_hotkeys::is_pressed()
-{
-  if (grab_key.key.sym!=0)
-    return pressed;
-  
-  return def_hot_keys->is_pressed();
-}
-
-void x11_hotkeys::ungrabkeys()
-{ 
-  if (grab_key.key.sym==0)
-    return;
-  Display *d=display;
-
-  for (int screen = 0; screen<ScreenCount(d); screen++) {
-    XUngrabKey(d, AnyKey, AnyModifier, RootWindow (d, screen));
-    XUngrabButton(d, AnyButton, AnyModifier, RootWindow (d, screen));
-  }  
-}
-
-GdkFilterReturn x11_hotkeys::key_filter(GdkXEvent *gdk_xevent, 
-				     GdkEvent *event,
-				     x11_hotkeys *th) 
-{
-  int type;
-  XKeyEvent *xevent;
-  
-  xevent = (XKeyEvent *)gdk_xevent;
-  type = xevent->type;
-  KeySym keysym = XKeycodeToKeysym(GDK_DISPLAY(), ((XKeyEvent *)xevent)->keycode, 0);
-  unsigned int state=xevent->state;
-  state &= ~(numlock_mask | capslock_mask | scrolllock_mask);
-  if (type == KeyPress) {    
-    if (keysym==th->grab_key.key.sym && state==th->grab_key.modifier) {
-      th->pressed=true;    
-    }
-  } else if (type==KeyRelease) {
-    if (keysym==th->grab_key.key.sym) {
-      th->pressed=false;
-    }
-  }
-
-  return GDK_FILTER_CONTINUE;
-}
diff --git a/src/x11_iskeyspressed.hpp b/src/x11_iskeyspressed.hpp
index f7391ad..8b13789 100644
--- a/src/x11_iskeyspressed.hpp
+++ b/src/x11_iskeyspressed.hpp
@@ -1,66 +1 @@
-#ifndef _X11_ISKEYSPRESSED_HPP_
-#define _X11_ISKEYSPRESSED_HPP_
 
-#include <memory>
-
-#include <gdk/gdkx.h>
-#include <X11/keysym.h>
-#include <gtk/gtk.h>
-
-#include "iskeyspressed.hpp"
-
-typedef enum { SYM, CODE, BUTTON } KeyType_t;
-typedef enum { PRESS, RELEASE } EventType_t;
-
-struct Keys_t {
-
-  KeyType_t type;
-
-  EventType_t event_type;
-
-  union {
-    KeySym sym;
-    KeyCode code;
-    unsigned int button;
-  } key;
-
-  unsigned int modifier;
-
-  Keys_t(KeyType_t t=SYM, EventType_t et=PRESS, KeySym s=0, unsigned int m=0) :
-    type(t), event_type(et), modifier(m) 
-  {
-    key.sym=s;
-  }
-};
-
-class x11_hotkeys : public hotkeys {
-public:
-  x11_hotkeys(GtkWindow *win_);
-	~x11_hotkeys();
-	const std::list<std::string>& possible_combs();
-  void set_comb(const std::string& comb);
-  bool is_pressed();
-private:
-  std::string comb;
-  GtkWindow *win;
-  bool pressed;
-  Keys_t grab_key;
-  std::list<std::string> possb_combs;
-  std::auto_ptr<hotkeys> def_hot_keys;/*I don't want to duplicate work, 
-																				so hold here pointer to default 
-																				object of this class*/
-  Display *display;
-  static unsigned int numlock_mask, scrolllock_mask, capslock_mask;
-
-  static GdkFilterReturn key_filter(GdkXEvent *gdk_xevent, 
-																		GdkEvent *event, x11_hotkeys *th);
-  void ungrabkeys(void);
-  static void get_offending_modifiers(Display * dpy);
-  static void my_grab_key(Display * dpy, KeyCode keycode, 
-													unsigned int modifier, Window win);
-  static void my_grab_button(Display * dpy, unsigned int button, 
-														 unsigned int modifier, Window win);
-  static bool grab_keys(Display *dpy, Keys_t keys[], int nb_keys);
-};
-
-#endif//!_X11_ISKEYSPRESSED_HPP_
